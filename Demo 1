// BIBLIOTECAS NECESARIAS
#include <Wire.h> 		
#include <LiquidCrystal_I2C.h> 
#include <DHT.h> 		
#include <virtuabotixRTC.h>

//PINES
#define DHTPIN 7
#define DHTTYPE DHT11   
#define UVPIN A2        //Pin de salida analógica del ML8511
#define BUZZER 6        //Pin digital para el buzzer

//"Crear el clock", CABLES = CLOCK-DATA-RESET (CLK-DAT-RST)
virtuabotixRTC myRTC(5, 4, 3);
DHT dht(DHTPIN, DHTTYPE);	
LiquidCrystal_I2C lcd(0x27, 16, 2); 

//PROGRAMA
void setup() {

  Serial.begin(9600);

  lcd.init();       //iniciar pantalla
  lcd.backlight();  //incender luz de fondo (necesario porque sino no se ve nada)
  dht.begin();      //iniciar sensor DHT
  lcd.setCursor(0, 0); // deja el cursor del LCD al comienzo para poder escribir
  lcd.print("Iniciando"); //mensajito ;)
  lcd.setCursor(0, 1); // paso a la parte de abajo 
  lcd.print("centralita..."); //mensajito ;)
  delay(2000);
  lcd.clear(); //limpia el LCD (el mensajito)
}


void loop() {
  myRTC.updateTime();
  // Variables del DHT
  float h = dht.readHumidity(); //lee la humedad
  float t = dht.readTemperature(); //lee la temperatura

  //Leer valor del ML8511
  int lecturaUV = analogRead(UVPIN);
  float voltage = lecturaUV * (5.0 / 1023.0); // Convertir a voltaje
  float indiceUV = mapfloat(voltage, 0.99, 2.9, 0.0, 15.0); 
  // 0.99V ~ 0 UV   |   2.9V ~ 15 UV (rango típico del ML8511)

  //Corrección para evitar valores negativos
  if (indiceUV < 0) {
    indiceUV = 0;
  }

  // Verificar errores del DHT
  if (isnan(h) && isnan(t)) { 
    lcd.setCursor(0, 0); lcd.print("Error de Sensor");
    lcd.setCursor(6, 1); lcd.print("DHT");
    return;
  } 
  else if (isnan(h)) { 
    lcd.setCursor(0, 0); lcd.print("Error de Sensor");
    lcd.setCursor(4, 1); lcd.print("Humedad");
    return;
  } 
  else if (isnan(t)) { 
    lcd.setCursor(0, 0); lcd.print("Error de Sensor");
    lcd.setCursor(2, 1); lcd.print("Temperatura");
    return;
    
  }
  lcd.clear(); //limpia el LCD (el mensajito)
  // Mostrar en el LCD
  // Mostrar fecha y hora durante 3 segundos
for (int i = 0; i <4 ; i++) {
  myRTC.updateTime();  // actualizar RTC
  lcd.setCursor(0, 0);
  lcd.print(myRTC.dayofmonth);
  lcd.print("/");
  lcd.print(myRTC.month);
  lcd.print("/");
  lcd.print(myRTC.year);

  lcd.setCursor(0, 1);
  if (myRTC.hours < 10) lcd.print("0");  
  lcd.print(myRTC.hours);
  lcd.print(":");
  if (myRTC.minutes < 10) lcd.print("0");
  lcd.print(myRTC.minutes);
  lcd.print(":");
  if (myRTC.seconds < 10) lcd.print("0");
  lcd.print(myRTC.seconds);

  delay(1000); // refresca cada 1 segundo
}
  lcd.clear();

  lcd.setCursor(0, 0);
  lcd.print("Temp: ");
  lcd.print(t);
  lcd.print((char)223); // Símbolo de grados "°" (el LCD no lo muestra bien sino)
  lcd.print("C");

  lcd.setCursor(0, 1);
  lcd.print("Humedad: ");
  lcd.print(h);
  lcd.print("%");

  delay(3000);
  lcd.clear();

  lcd.setCursor(0, 0);
  lcd.print("Indice UV:");
  lcd.print(indiceUV, 1); // 1 decimal


  // ---- CONTROL DEL BUZZER ----
  if (indiceUV > 8) {
    lcd.setCursor(4,1);
    lcd.print("PELIGRO");
    for (int i=0; i<3; i++){
      beep(3000); // 1000 Hz 
    }  
  }

  delay(2000); // Actualiza cada segundo
}

// -------- FUNCIONES --------
// Beep para buzzer pasivo (con tono)
void beep(int frecuencia) {
  tone(BUZZER, frecuencia); // Arranca el tono
  delay(500);            // Lo mantiene
  noTone(BUZZER);           // Lo apaga
  delay(1000);               // Pausa entre beeps
}

// Función auxiliar para mapear float (igual que map() pero con decimales)
float mapfloat(float x, float in_min, float in_max, float out_min, float out_max) {
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

