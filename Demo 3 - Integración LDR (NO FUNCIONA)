//--------------------------------------------------------- BIBLIOTECAS NECESARIAS ---------------------------------------------------------
#include <Wire.h> 		
#include <LiquidCrystal_I2C.h> 
#include <DHT.h> 		
#include <virtuabotixRTC.h>

//------------------------------------------------------------------ PINES ------------------------------------------------------------------
#define DHTPIN 7
#define DHTTYPE DHT11   
#define UVPIN A2        // Pin de salida analógica del ML8511
#define BUZZER 6        // Pin digital para el buzzer
int PINFOTORRES = A5;

//----------------------------------------------------------------- OBJETOS -----------------------------------------------------------------
// "Crear el clock", CABLES = CLOCK-DATA-RESET (CLK-DAT-RST)
virtuabotixRTC myRTC(5, 4, 3);
DHT dht(DHTPIN, DHTTYPE);	
LiquidCrystal_I2C lcd(0x27, 16, 2); 

//--------------------------------------------------------------- PROTOTIPOS ---------------------------------------------------------------
void inicio();
void fechayHora();
float temperaturayHumedad(float h, float t);
float UV();
void controlBuzzer(float indiceUV);
int lecturaFotorres(int valorFotorres);
int mapearFotorres(int valorFotorres);

//----------------------------------------------------------------- SETUP -----------------------------------------------------------------
void setup() {

  Serial.begin(9600);
  inicio();
  // Configurar fecha y hora (solo la 1ra vez)
 
}

//------------------------------------------------------------------ LOOP ------------------------------------------------------------------
void loop() {
  lcd.clear();
  myRTC.updateTime();
  
  // Variables del DHT
  float h = dht.readHumidity(); // lee la humedad
  float t = dht.readTemperature(); //lee la temperatura
  //Variables de la Fotorresistencia
  int valorFotorres = analogRead(PINFOTORRES);
  // Mostrar en el LCD
  fechayHora();
  lcd.clear();

  temperaturayHumedad(h, t);
  lcd.clear();

  lecturaFotorres(valorFotorres);
  lcd.clear();

  float indiceUV = UV();
  controlBuzzer(indiceUV); // maneja el buzzer según el índice

  delay(2000); // Actualiza cada segundo
}

//--------------------------------------------------------------- FUNCIONES ---------------------------------------------------------------
void inicio(){
  lcd.init();       // iniciar pantalla
  lcd.backlight();  // incender luz de fondo (necesario porque sino no se ve nada)
  dht.begin();      // iniciar sensor
  lcd.setCursor(0, 0); // deja el cursor del LCD al comienzo para poder escribir
  lcd.print("Iniciando"); //mensajito ;)
  lcd.setCursor(0, 1); // paso a la parte de abajo 
  lcd.print("centralita..."); //mensajito ;)
  delay(2000);
}

float temperaturayHumedad(float h, float t){
  // Mostrar temperatura y humedad durante 4 segundos
  for (int i = 0; i < 4; i++) {
    h = dht.readHumidity(); // lee la humedad
    t = dht.readTemperature(); //lee la temperatura

    lcd.setCursor(3, 0);
    lcd.print("Temp: ");
    lcd.print(t);
    lcd.print((char)223); // Símbolo de grados "°" (el LCD no lo muestra bien sino)
    lcd.print("C   ");    // limpiar restos anteriores

    lcd.setCursor(0, 1);
    lcd.print("Humedad: ");
    lcd.print(h);
    lcd.print("%   ");    // limpiar restos anteriores

    delay(1000); // refresca cada 1 segundo
  }
}

void fechayHora(){
    // Mostrar fecha y hora durante 4 segundos
  for (int i = 0; i <4 ; i++) {
    myRTC.updateTime();  // actualizar RTC
    lcd.setCursor(4, 0);
    lcd.print(myRTC.dayofmonth);
    lcd.print("/");
    lcd.print(myRTC.month);
    lcd.print("/");
    lcd.print(myRTC.year);

    lcd.setCursor(4, 1);
    if (myRTC.hours < 10) lcd.print("0");  
    lcd.print(myRTC.hours);
    lcd.print(":");
    if (myRTC.minutes < 10) lcd.print("0");
    lcd.print(myRTC.minutes);
    lcd.print(":");
    if (myRTC.seconds < 10) lcd.print("0");
    lcd.print(myRTC.seconds);

    delay(1000); // refresca cada 1 segundo
  }

}

float UV(){
  float indiceUV = 0;
  // Mostrar índice UV durante 3 segundos
  for (int i = 0; i < 3; i++) {
    int lecturaUV = analogRead(UVPIN);
    float voltage = lecturaUV * (5.0 / 1023.0); // Convertir a voltaje
    indiceUV = mapfloat(voltage, 0.99, 2.9, 0.0, 15.0); 
    // 0.99V ~ 0 UV   |   2.9V ~ 15 UV (rango típico del ML8511)
    // Corrección para evitar valores negativos
    if (indiceUV < 0) {
      indiceUV = 0;
    }
    lcd.setCursor(0, 0);
    lcd.print("Indice UV: "); 
    lcd.print(indiceUV, 1); // 1 decimal

    delay(1000); // refresca cada 1 segundo
  }
  return indiceUV;
}

// Función auxiliar para mapear float (igual que map() pero con decimales)
float mapfloat(float x, float in_min, float in_max, float out_min, float out_max) {
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}


void controlBuzzer(float indiceUV) {
  if (indiceUV > 8) {   // condición de peligro
    lcd.setCursor(4, 1);
    lcd.print("PELIGRO");
    for(int j=0; j<2; j++){
      for (int k = 0; k < 3; k++) {
        tone(BUZZER, 700); // Arranca el tono
        delay(300);         // Lo mantiene
        noTone(BUZZER);     // Lo apaga
        delay(500);        // Pausa entre beeps
      }
    }
  }
}

int lecturaFotorres(int valorFotorres){
  // Mostrar y actualizar durante 3 segundos
  for (int i = 0; i < 3; i++) {
    valorFotorres = analogRead(PINFOTORRES);  // leer otra vez
    int mapeo = mapearFotorres(valorFotorres);

    lcd.setCursor(1, 0);
    lcd.print("Luz Ambiental:   "); // limpiar restos anteriores
    lcd.setCursor(6, 1);
    lcd.print("     ");             // limpiar antes de escribir
    lcd.setCursor(7, 1);
    lcd.print(mapeo);
    lcd.print("%");

    delay (1000); // espera 1 segundo antes de actualizar de nuevo
  }
}

int mapearFotorres(int valorFotorres){
  // Forzar los límites antes de mapear
  valorFotorres = constrain(valorFotorres, 0, 1023);
  return map(valorFotorres, 1023, 0, 0, 100);
}
